


 *** getData<NewsFeed[]>와  getData<NewsDetail> 의 차이 

getData<NewsFeed[]>(NEWS_URL)에서 꺾쇠 괄호([]) 안에 있는 것은 TypeScript에서 배열 타입을 나타냅니다. 따라서 getData<NewsFeed[]>(NEWS_URL)는 NEWS_URL에서 가져온 데이터가 NewsFeed 객체들로 이루어진 배열일 것으로 기대한다는 것을 TypeScript에게 알려주는 것입니다.

반면에 getData<NewsDetail>(CONTENT_URL.replace("@id", id))에서는 꺾쇠 괄호 안에 배열 표시가 없습니다. 이는 CONTENT_URL.replace("@id", id)에서 가져온 데이터가 NewsDetail 타입의 단일 객체일 것으로 기대한다는 것을 의미합니다.

이 꺾쇠 괄호 안에 배열 표시를 사용하느냐 아니냐의 결정은 API 엔드포인트에서 기대하는 데이터의 구조에 달려 있습니다. 엔드포인트가 NewsDetail 객체들로 이루어진 배열을 반환한다면 배열 표시를 사용해야 합니다. 그러나 현재의 경우 CONTENT_URL.replace("@id", id) 엔드포인트가 단일 객체를 반환하는 것으로 보이므로 배열 표시를 사용하지 않습니다.


=> 즉 NewsFeed는 배열로 이루어진 여러개의 객체를 반환하고, NewsDetail은 하나의 객체를 반환하기 때문에 
[]의 여부의 차이가 있다.



타입앨리아스 vs 인터페이스 

출처 : https://tecoble.techcourse.co.kr/post/2022-11-07-typeAlias-interface/;

 type alias는 모든(any) 타입에 이름을 달아줄 수 있지만, interface는 오직 객체 타입에만 가능하다는 것이다. 이것이, type alias와 interface에 가장 명확한 차이가 아닐까한다.
 type alias는 새로운 프로퍼티에 열려있지 않다는 것이고, interface는 항상 열려있다
 interface 키워드를 통해서 선언된 Window라는 타입을 선언한 후, 바로 아래에서 다시 다른 프로퍼티를 가진 Window 타입을 선언해주었다. 선언된 타입의 이름과 같은 이름으로 새로운 타입을 선언했지만, 에러가 나지 않고 나중에 선언된 타입의 프로퍼티를 가지고 있는 것을 볼 수 있다. 그래서, interface는 확장 가능하다라고 설명하는 것 같다. (이를, 선언 병합이라고 한다.)


https://tecoble.techcourse.co.kr/static/33901ee3f6eecc05ab8b35de2871a072/0e821/2022-11-07-interfacetype-interfacevstype.png
이에 반해, 오른쪽 코드를 보면 type alias를 통해서 Window 타입을 선언해주고, 다시 아래에서 Window 타입을 재선언 해주고 있다. interface에서는 에러가 나지 않앗지만, 여기서는 식별자 ‘Window’가 중복된다라는 에러를 보여주고 있다. 그래서, type은 새로운 프로퍼티를 추가할 수 없다고 하는 것 같다.

확장 가능하지 않도록 타입을 선언할 수 있는(type alias) 방법이 존재하는 이유는 조금 명확한 것 같다. 타입의 속성들이 추후에 추가될 수도 있다면, 개발자들은 타입이 변할 수도 있다는 생각을 하면서 개발을 해야하기 때문이다. (마치 let보다는 const를 활용하여 상수로 선언해주는 게 좋은 이유가 비슷한 맥락이 아닐까 한다.)

그렇다면, 확장 가능한 방법은 어느 상황에서 필요할까?

먼저, interface를 활용하면 선언 병합(Declaration merging)이라는 것이 가능하다. 아래의 코드처럼, 기존에 선언된 타입을 확장해서 다른 속성을 추가로 선언할 수 있는 것이다.

interface Person {
  name: string;
}

interface Person {
  age: number;
}

const user: Person = {
  name: 'al-bur',
  age: 21,
};

type-alias는 모든 타입을 선언할 때 사용될 수 있고, interface는 객체에 대한 타입을 선언할 때 사용될 수 있다. 둘 다 객체에 대한 타입을 선언하는 데 사용될 수 있는데, 확장 측면에서 사용 용도가 달라진다. 확장이 불가능한 타입을 선언하려면 type-alias를 사용하면 되고, 확장이 가능한 타입을 선언하려면 선언 병합이 가능한 interface를 사용하면 된다.

타입 앨리어스 (type)

구조적인 타입: 타입 앨리어스는 구조적인 타입을 생성할 수 있습니다. 즉, 타입의 구조를 유연하게 정의할 수 있습니다.

유니온 및 인터섹션: type은 유니온(|) 및 인터섹션(&) 등을 사용하여 복잡한 타입을 생성하는 데 더 적합합니다.

단일 이름으로 재사용: 한 번 정의한 타입 앨리어스를 여러 곳에서 재사용할 수 있습니다.

일반적으로 리터럴, 유니온, 튜플 등 간단한 타입 정의에 사용됩니다.

인터페이스 (interface)

타입 앨리어스에서 지원하는 유니온타입을 지원하지 않음 ( string |  null )

명명된 구조: 인터페이스는 명명된 구조로 명시적인 이름을 가지며, 주로 클래스나 객체의 구조를 정의하는 데 사용됩니다.

상속 및 확장: 인터페이스는 상속과 확장이 가능하며, extends 키워드를 사용하여 다른 인터페이스로부터 상속할 수 있습니다.

추상 클래스: 클래스의 일종으로 사용되어 추상 메서드와 속성을 정의할 수 있습니다.

클래스와 호환성: 인터페이스는 클래스와의 호환성을 확인하는 데 사용됩니다.

=> 즉 구조적 타입이 필요한 경우는 타입 앨리어스 사용 ,명시적인 구조가 필요한 경우 또는 클래스를 선언할 때 인터페이스 사용